<html>
<head>
    <meta charset="utf-8">
</head>
<body>
<script src="./Football.js"></script>

<script> 	
// WORKING with 3 ARRAYS: R1 R2 R3 R4 R5 R6 R7 R8 R9 R10  S1 S2 S3 S4 S5 S6 S7 S8 S9 S10  T1 T2 T3 T4 T5 T6 T7 T8 T9 T10

const Rounds =[
              // ROUND xx
               [ [1.57,4.65,2.54,6.93,2.6,1.86,2.42,2.02,1.24,4.35], 
                 [3.99,3.53,3.09,3.93,3.38,3.61,3.21,3.2,6.84,4.02], 
                 [7.33,1.88,3.22,1.58,2.85,4.62,3.3,4.49,12.5,1.82]
               ],

             [   [1.57,4.65,2.54,6.93,2.6], 
                 [3.99,3.53,3.09,3.93,3.38], 
                 [7.33,1.88,3.22,1.58,2.85]
              ],
               [ [1.86,2.42,2.02,1.24,4.35], 
                 [3.61,3.21,3.2,6.84,4.02], 
                 [4.62,3.3,4.49,12.5,1.82]
              ],

            ];


            // Round 2 2
            //    [ [3.29, 2.09, 1.27, 2.15, 1.83, 1.84, 1.08, 2.43, 5.89, 7.89], 
            //      [3.13, 3.56, 6.21, 3.38, 3.55, 3.78, 13.02, 3.08, 3.6, 5.19	], 
            //      [2.44, 3.68, 11.99, 3.71, 4.89, 4.44, 35.88, 3.38, 1.71, 1.4]
            //    ],

            //  [   [3.29, 2.09, 1.27, 2.15, 1.83], 
            //      [3.13, 3.56, 6.21, 3.38, 3.55], 
            //      [2.44, 3.68, 11.99, 3.71, 4.89]
            //   ],
            //    [ [1.84, 1.08, 2.43, 5.89, 7.89], 
            //      [3.78, 13.02, 3.08, 3.6, 5.19], 
            //      [4.44, 35.88, 3.38, 1.71, 1.4]
            //   ],
const ar1 = ["H1","H2","H3","H4","H5","H6","H7","H8","H9","H10"];
const ar2 = ["D1","D2","D3","D4","D5","D6","D7","D8","D9","D10"];
const ar3 = ["A1","A2","A3","A4","A5","A6","A7","A8","A9","A10"];
const len2 = 3**ar1.length;

//=======================================================
const ar1_first_half = ["H1","H2","H3","H4","H5"];
const ar2_first_half = ["D1","D2","D3","D4","D5"];
const ar3_first_half = ["A1","A2","A3","A4","A5"];

//=======================================================
const ar1_second_half = ["H6","H7","H8","H9","H10"];
const ar2_second_half = ["D6","D7","D8","D9","D10"];
const ar3_second_half = ["A6","A7","A8","A9","A10"];

const len3 = 3**ar1_first_half.length;

	
function secondMarketTwo(){
	let resultArr =[];
	for (let i = 0; i < len2; ++i) {
	let k = i;
	const arr = [];
	for (let j = 0; j < ar3.length; ++j) {
	   let y = k % 3;
	   switch(y){
	      case 0: arr.push(ar3[j]); break;
	      case 1: arr.push(ar2[j]); break;
	      case 2: arr.push(ar1[j]); break;
	   }
	  k = Math.floor(k / 3);
	}
	//console.log(arr);
	resultArr.push(arr);
	}
	return resultArr;
}

function secondMarketTwo_hf1(){
	let resultArr =[];
	for (let i = 0; i < len3; ++i) {
	let k = i;
	const arr = [];
	for (let j = 0; j < ar1_first_half.length; ++j) {
	   let y = k % 3;
	   switch(y){
	      case 0: arr.push(ar3_first_half[j]); break;
	      case 1: arr.push(ar2_first_half[j]); break;
	      case 2: arr.push(ar1_first_half[j]); break;
	   }
	  k = Math.floor(k / 3);
	}
	//console.log(arr);
	resultArr.push(arr);
	}
	return resultArr;
}

function secondMarketTwo_hf2(){
	let resultArr =[];
	for (let i = 0; i < len3; ++i) {
	let k = i;
	const arr = [];
	for (let j = 0; j < ar1_second_half.length; ++j) {
	   let y = k % 3;
	   switch(y){
	      case 0: arr.push(ar3_second_half[j]); break;
	      case 1: arr.push(ar2_second_half[j]); break;
	      case 2: arr.push(ar1_second_half[j]); break;
	   }
	  k = Math.floor(k / 3);
	}
	//console.log(arr);
	resultArr.push(arr);
	}
	return resultArr;
}



console.log(secondMarketTwo_hf1());

console.log(secondMarketTwo_hf2());


// // ROIND 6
const H_odds_1 = Rounds[0][0];
const D_odds_1 = Rounds[0][1];
const A_odds_1 = Rounds[0][2];
// first half of the 10 games
const H_odds_11 = Rounds[1][0];
const D_odds_11 = Rounds[1][1];
const A_odds_11 = Rounds[1][2];
// Second half of the 10 games
const H_odds_12 = Rounds[2][0];
const D_odds_12 = Rounds[2][1];
const A_odds_12 = Rounds[2][2];

		
//if the average of arrays of H to D > (H+D)/3 return H  else if av D+A <1 return D : H



// Get List of Min Odds for each round, Min Odds implies min for HOME DRAW and AWAY for each game
function getMinOddList(H_o, D_o, A_o){
    let  newList =[], index =0;
    while(index<H_o.length){
        let min = Math.min(H_o[index], D_o[index], A_o[index]);
        newList.push(min);
        index++;
    }
    return newList;
}


// Get list of all Maximum odds for each round
function getMaxOddList(H_o, D_o, A_o){
    let  newList =[], index =0;
    while(index<H_o.length){
        let min = Math.max(H_o[index], D_o[index], A_o[index]);
        newList.push(min);
        index++;
    }
    return newList;
}


// this function returns the count of min odds in a given combination
function getMinOddCountPerGame(minOddArray,gameArray){
     let counter =0;
     for(let j =0; j< gameArray.length; j++){
         if(gameArray.includes(minOddArray[j])){
            counter+=1;
         }
     }
     return counter;
}


// this function returns the count of Max odds in a given combination
function getMaxOddCountPerGame(maxOddArry,gameArray){
    let counter =0;
     for(let j =0; j< gameArray.length; j++){
         if(gameArray.includes(maxOddArry[j])){
            counter+=1;
         }
     }
     return counter;
}


// some form of criteria
function criteria(){
     let index = 0, newArray =[];
     while(index<10){
           let averageOf_3 = (H_odds_1[index] + D_odds_1[index] + A_odds_1[index])/3;
           let H_D_average = (H_odds_1[index] + D_odds_1[index])/3;
           let D_A_average = (D_odds_1[index]+ A_odds_1[index])/2;

           if(averageOf_3 > H_D_average){
               newArray.push(H_odds_1[index]);
           }else if(D_A_average<1){
               newArray.push(D_odds_1[index]);
           }else{
               newArray.push(H_odds_1[index]);
           }
          index++;
     }
     return newArray;
}


// const H_odds_1 = [1.57,4.65,2.54,6.93,2.6,1.86,2.42,2.02,1.24,4.35];
// const D_odds_1 = [3.99,3.53,3.09,3.93,3.38,3.61,3.21,3.2,6.84,4.02];
// const A_odds_1 = [7.33,1.88,3.22,1.58,2.85,4.62,3.3,4.49,12.5,1.82];
// GG Criteria

// Outputs the List of minimum odds in a given round
// console.log(getMinOddList(H_odds_1,D_odds_1,A_odds_1));

//==================================================================================================================================//
// Criteria Criteria  Criteria
// FH= (H+A+D)/15+(H+D)/10+ A/5

function fh_criteia(h,d,a){
    let fh = [];
    for( let i =0; i<h.length; i++){
        let fhn = ((h[i] + d[i] + a[i])/3 + (h[i] + d[i])/2 + a[i])/5;
            fhn =  Number(fhn.toFixed(2));
        fh.push(fhn);
    }
    return fh;
}


//FA= (H+A+D)/15+(A+D)/10+ H/5
function fa_criteria(h,d,a){
    let fa = [];
    for( let i =0; i<h.length; i++){
        let fan = ((h[i] + d[i] + a[i])/3 + (a[i] + d[i])/2 + h[i])/5;
            fan = Number(fan.toFixed(2));
        fa.push(fan);
    }
    return fa;
}


// Computing the F* Criteria for the entire Rounds
let winOddArray = [];
Rounds.forEach((a,index)=>{
    // fint the strt time
    let starTime = performance.now();
        let FH = fh_criteia(a[0],a[1],a[2]),
            FA = fa_criteria(a[0],a[1],a[2]);

        let _p = (ar)=>{
                let prod =1;
                for(let i =0; i<ar.length; i++){
                    prod*=ar[i];
                }
                return prod;
          };
    let fh_product = _p(FH), 
                 w1 = Number((fh_product/2).toFixed(2)),     // Half of Fh_product
                 w3 = Number((1.5*fh_product).toFixed(2));   // w1 is the half of FH_product

    let fa_product = _p(FA), 
        w2  = Number((fa_product/2).toFixed(2)),    // Half of the FA_product
        w4  =  Number((1.5*fa_product).toFixed(2));  // w2 is the half of Fa_product

      
       let w5 = Number((fh_product + fa_product).toFixed(2));    // sum of the FH_pro and FA_pro
       
       // get the product of even position of FA & Odd position of FH AND that of odd positionof FA & even position of FH
       let prodFunc = (a1, a2)=>{
                let _pr = 1, counter =0;
               while(counter < a1.length){
                    if(counter>0 && counter%2 == 0){
                        _pr*=a1[counter]*a2[counter+1];
                    }else{
                        _pr*=a1[counter]*a2[counter+1]
                    }
               }
       }

       // function to calcuate the average of the odd and event position values of both the FH and FA
       let _swapFunc =(r1,r2)=>{
              let _product =1, _product2 =1; 
              for(let i =0; i<r1.length; i++){
                if(i%2==0){ _product*=r1[i]; } // taking odd position
              }
              for(let j =0; j<r2.length; j++){
                    if(j%2==1){ _product2*=r1[j];}  // taking even position
             }
         return Number((_product*_product2)/10);
       } 
        let w6 = _swapFunc(FA,FH) + _swapFunc(FH,FA) ,
            w7 =  w5 - w6;


      winOddArray.push({
             'FH':FH,
             'FA':FA,
             'FH_P':fh_product,
             'FA_P':fa_product,
             'w1':w1,
             'w2':w2,
             'w3':w3,
             'w4':w4,
             'w5':w5,
             'w6':w6,
             'w7':w7,
      });
      let endTime = performance.now();
      //console.log(endTime - starTime);
});

//console.log(winOddArray);


 


// GG/NG Criteria
function ggCriteria(){
    let index =0, gg_od_rray=[], ng_odd_array =[];
        while(index<10){
            let gg = ((((H_odds_1[index]*A_odds_1[index]) +  H_odds_1[index])**2))/(((D_odds_1[index]*D_odds_1[index]) + H_odds_1[index])**2 );
            let ng = ((((A_odds_1[index]*A_odds_1[index]) +  H_odds_1[index])))/(((H_odds_1[index]*A_odds_1[index]) + A_odds_1[index]) );
            gg_od_rray.push(gg);
            ng_odd_array.push(ng);
            index++;
        }  
  return [{'GG':gg_od_rray,'NG':ng_odd_array}];
}


//console.log(ggCriteria());

//===========================================================================================================================================


// this function calculates the proucduct of odds using the output of the criteria funtion a bove
function productOfOddsByCriteria(givenArray){ 
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){
         oddProduct  = oddProduct*givenArray[j]; 
    }
   return  Number(oddProduct.toFixed(4));
}

// this looks like the reverse bc of the indexing of arrays
function productOfEvenPositionByCriteria(givenArray){
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){  
      let test  = j%2;
      if(test==1){
          oddProduct  = oddProduct*givenArray[j]; 
      }
    }
   return  Number(oddProduct.toFixed(4));
}

// this looks like the reverse bc of the indexing of arrays
function productOfOddPositionByCriteria(givenArray){
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){ 
      let test  = j%2;
      if(test==0){
          oddProduct  = oddProduct*givenArray[j]; 
      }
    }
   return  Number(oddProduct.toFixed(4));
}





// this function calulates the product of the first five odds in  an array
function productOfFirst_5(givenArray){
     let oddProduct =1;
    for(let j=0; j< givenArray.length/2; j++){
        oddProduct  = oddProduct*givenArray[j];     
    }
   return  Number(oddProduct.toFixed(4));   
}


// This function calulates the product of the last five odds
function productOfLast_5(givenArray){
     let oddProduct = 1;
    for(let j=5; j< givenArray.length; j++){ 
        oddProduct  = oddProduct*givenArray[j]; 
    }
   return  Number(oddProduct.toFixed(4));  
}




//ar1,ar2,ar3
let PossibleOutCome = secondMarketTwo();
let PossibleOut_hf1 = secondMarketTwo_hf1();
let PossibleOut_hf2 = secondMarketTwo_hf2();

let pd=[], sm=[];
function findProductAndSum(givenArray){
    let ar1HomeCounter=0, ar2DCounter=0, ar3ACounter=0, resultArray=[]; 
    
    givenArray.forEach((ar,i)=>{
    let oddProduct =1, oddSum = 0;
    for(let j=0; j< ar.length; j++){
      let itemIndex;  // index of the item in the Original Array
      if(ar[j].includes("H")){
          itemIndex   = ar1.indexOf(ar[j]);
          oddProduct  = oddProduct*H_odds_1[itemIndex];
          oddSum      = oddSum + H_odds_1[itemIndex];
      }else if(ar[j].includes("D")){
          itemIndex   = ar2.indexOf(ar[j]); 
          oddProduct  = oddProduct*D_odds_1[itemIndex];
          oddSum      = oddSum + D_odds_1[itemIndex];
      }else{
          itemIndex   = ar3.indexOf(ar[j]);
          oddProduct  = oddProduct*A_odds_1[itemIndex];
          oddSum      = oddSum + A_odds_1[itemIndex];
      }

    }
    resultArray.push({"Product":Number(oddProduct.toFixed(1)),"SumofOdds":Number(oddSum.toFixed(1))});
    pd.push(Number(oddProduct.toFixed(4)));
    sm.push(Number(oddSum.toFixed(4)));
});

return resultArray;
}

let prod_sum = findProductAndSum(PossibleOutCome);  // initiate the function




// // Maximum Product and Max Sum
// console.log(Math.max(...pd));
// console.log(Math.max(...sm));

// // minimum product and minnimun sum
// console.log(Math.min(...pd));
// console.log(Math.min(...sm));
function addTwoNumbers(a,b){
     return (a+b);
}

// This function returns the sum of the ods of a given array of odds
function findSumOfOdds(givenArray){ 
    let oddSum = 0;
    for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array
      if(givenArray[j].includes("H")){
          itemIndex   = ar1.indexOf(givenArray[j]);
          oddSum      = oddSum + H_odds_1[itemIndex]; 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2.indexOf(givenArray[j]); 
          oddSum      = oddSum + D_odds_1[itemIndex]; 
      }else{
          itemIndex   = ar3.indexOf(givenArray[j]);
          oddSum      = oddSum + A_odds_1[itemIndex]; 
      }

    }
   return  Number(oddSum.toFixed(4));
}

// This function returns the sum of the odds of a given array of odds
function findSumOfOddsWithParams(givenArray,homeOddsArray,drawOddsArray, awayOdssArray){ 
    let oddSum = 0;
    for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array
      if(givenArray[j].includes("H")){
          itemIndex   = ar1.indexOf(givenArray[j]);
          oddSum      = oddSum + homeOddsArray[itemIndex]; 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2.indexOf(givenArray[j]); 
          oddSum      = oddSum + drawOddsArray[itemIndex]; 
      }else{
          itemIndex   = ar3.indexOf(givenArray[j]);
          oddSum      = oddSum + awayOdssArray[itemIndex]; 
      }

    }
   return  Number(oddSum.toFixed(4));
}



// this finction finds the product of the odds of any given set of odds in array form
function findProductOfOdds(givenArray){ 
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array
      if(givenArray[j].includes("H")){
          itemIndex   = ar1.indexOf(givenArray[j]);
          oddProduct  = oddProduct*H_odds_1[itemIndex]; 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2.indexOf(givenArray[j]); 
          oddProduct  = oddProduct*D_odds_1[itemIndex]; 
      }else{
          itemIndex   = ar3.indexOf(givenArray[j]);
          oddProduct  = oddProduct*A_odds_1[itemIndex]; 
      }

    }
   return  Number(oddProduct.toFixed(2));
}
// this finction finds the product of the odds of any given set of odds in array form
function findProductOfOdds_hf1(givenArray){ 
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array
      if(givenArray[j].includes("H")){
          itemIndex   = ar1_first_half.indexOf(givenArray[j]);
          oddProduct  = oddProduct*H_odds_11[itemIndex]; 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2_first_half.indexOf(givenArray[j]); 
          oddProduct  = oddProduct*D_odds_11[itemIndex]; 
      }else{
          itemIndex   = ar3_first_half.indexOf(givenArray[j]);
          oddProduct  = oddProduct*A_odds_11[itemIndex]; 
      }

    }
   return  Number(oddProduct.toFixed(4));
}

// this finction finds the product of the odds of any given set of odds in array form
function findProductOfOdds_hf2(givenArray){ 
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array
      if(givenArray[j].includes("H")){
          itemIndex   = ar1_second_half.indexOf(givenArray[j]);
          oddProduct  = oddProduct*H_odds_12[itemIndex]; 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2_second_half.indexOf(givenArray[j]); 
          oddProduct  = oddProduct*D_odds_12[itemIndex]; 
      }else{
          itemIndex   = ar3_second_half.indexOf(givenArray[j]);
          oddProduct  = oddProduct*A_odds_12[itemIndex]; 
      }

    }
   return  Number(oddProduct.toFixed(4));
}

// this looks like the reverse bc of the indexing of arrays
function findProductOfEvenPosition(givenArray){
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array
      let test  = j%2;
      if(test==1){
        if(givenArray[j].includes("H")){
          itemIndex   = ar1.indexOf(givenArray[j]);
          oddProduct  = oddProduct*H_odds_1[itemIndex]; 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2.indexOf(givenArray[j]); 
          oddProduct  = oddProduct*D_odds_1[itemIndex]; 
      }else{
          itemIndex   = ar3.indexOf(givenArray[j]);
          oddProduct  = oddProduct*A_odds_1[itemIndex]; 
      }
      }
    }
   return  Number(oddProduct.toFixed(4));
}

// this looks like the reverse bc of the indexing of arrays
function findProductOfOddPosition(givenArray){
    let oddProduct =1;
    for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array
      let test  = j%2;
      if(test==0){
        if(givenArray[j].includes("H")){
          itemIndex   = ar1.indexOf(givenArray[j]);
          oddProduct  = oddProduct*H_odds_1[itemIndex]; 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2.indexOf(givenArray[j]); 
          oddProduct  = oddProduct*D_odds_1[itemIndex]; 
      }else{
          itemIndex   = ar3.indexOf(givenArray[j]);
          oddProduct  = oddProduct*A_odds_1[itemIndex]; 
      }
      }
    }
   return  Number(oddProduct.toFixed(4));
}
 
// function returns the array of odds of a given combination
function getCombinationOdds(givenArray){
     let newArray =[];
     for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array 
        if(givenArray[j].includes("H")){
          itemIndex   = ar1.indexOf(givenArray[j]);
          newArray.push(H_odds_1[itemIndex]); 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2.indexOf(givenArray[j]); 
         newArray.push(D_odds_1[itemIndex]); 
      }else{
          itemIndex   = ar3.indexOf(givenArray[j]);
          newArray.push(A_odds_1[itemIndex]); 
      }
      
    }
    return newArray;
}
// function returns the array of odds of a given combination
function getCombinationOdds_hf1(givenArray){
     let newArray =[];
     for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array 
        if(givenArray[j].includes("H")){
          itemIndex   = ar1_first_half.indexOf(givenArray[j]);
          newArray.push(H_odds_11[itemIndex]); 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2_first_half.indexOf(givenArray[j]); 
         newArray.push(D_odds_11[itemIndex]); 
      }else{
          itemIndex   = ar3_first_half.indexOf(givenArray[j]);
          newArray.push(A_odds_11[itemIndex]); 
      }
      
    }
    return newArray;
}
// function returns the array of odds of a given combination
function getCombinationOdds_hf2(givenArray){
     let newArray =[];
     for(let j=0; j< givenArray.length; j++){
      let itemIndex;  // index of the item in the Original Array 
        if(givenArray[j].includes("H")){
          itemIndex   = ar1_second_half.indexOf(givenArray[j]);
          newArray.push(H_odds_12[itemIndex]); 
      }else if(givenArray[j].includes("D")){
          itemIndex   = ar2_second_half.indexOf(givenArray[j]); 
         newArray.push(D_odds_12[itemIndex]); 
      }else{
          itemIndex   = ar3_second_half.indexOf(givenArray[j]);
          newArray.push(A_odds_12[itemIndex]); 
      }
      
    }
    return newArray;
}
//At most 5 draws //At least 2 Home  //At least 1 Away  sumof the even and odd products <135


//this function returns the total count of odd >=5.5 in a group of 10 games
function oddCompare(inputArray,numToCompareWith){
    let counter =0;
    for(let j=0; j< inputArray.length; j++){
            if(inputArray[j]>=numToCompareWith){
                counter+=1;
            }
    }
    return counter;
}


// This function Attempts to count the number of home wins whose odd > 2.89
function homeWinCount(gameArray,oddArray,num2Compare){
    let counter =0;
     for(let j=0; j< gameArray.length; j++){
        if(gameArray[j].includes("H")){
            let index = gameArray.indexOf(gameArray[j]),
            HomeOdd = oddArray[index];
            if(HomeOdd > num2Compare){
                counter+=1;
            }
            
        }
     }
     return counter;
}


// This function Attempts to count the number of home wins whose odd > 2.89
function aWayWinCount(gameArray,oddArray,num2Compare){
    let counter =0;
     for(let j=0; j< gameArray.length; j++){
        if(gameArray[j].includes("A")){
            let index = gameArray.indexOf(gameArray[j]),
            HomeOdd = oddArray[index];
            if(HomeOdd > num2Compare){
                counter+=1;
            }
            
        }
     }
     return counter;
}


// This function Attempts to count the number of home wins whose odd > 2.89
function drawWinCount(gameArray,oddArray,num2Compare){
    let counter =0;
     for(let j=0; j< gameArray.length; j++){
        if(gameArray[j].includes("D")){
            let index = gameArray.indexOf(gameArray[j]),
            HomeOdd = oddArray[index];
            if(HomeOdd > num2Compare){
                counter+=1;
            }
            
        }
     }
     return counter;
}


// for the entire 10 Games 
function filterMaches(arr){
    let pp =[];   // this array holds the count for each market
    arr.forEach((ar,index)=>{
         let ar1HomeCounter=0, ar2DCounter=0, ar3ACounter=0;
		 let newArr =[];
		 for(let j=0; j< ar.length; j++){
		     if(ar1.includes(ar[j])){   // ar1 Home odds
			    ar1HomeCounter = ar1HomeCounter+1;
				newArr.push(ar1[j]);
				
			 } else if(ar2.includes(ar[j])){  // ar2 Draw odds 
			    ar2DCounter = ar2DCounter+1;
				newArr.push(ar2[j]);
			 }
			 else if(ar3.includes(ar[j])){   //ar3 Away odds 
			    ar3ACounter = ar3ACounter+1;
				newArr.push(ar3[j]);
			 }else{
			    // do nothing
				console.log("nothig to do");
			 }
		 }
	//pp.push([index,[['H',ar1HomeCounter],['D',ar2DCounter], ['A',ar3ACounter]]]);
     let firstFiveProduct = productOfFirst_5(getCombinationOdds(newArr)); 
     let lastFiveProduct  = productOfLast_5(getCombinationOdds(newArr));
     let first_to_last    = parseFloat((firstFiveProduct/lastFiveProduct).toFixed(3)),
         last_to_first    = parseFloat((lastFiveProduct/firstFiveProduct).toFixed(3));

    let combinedOdd    = getCombinationOdds(newArr),    // get the odd list of the game combination
        centralCounter = oddCompare(combinedOdd,5.5),    // get the number of odd in the odd list whose value is greater than 5.5
        homeWins       = homeWinCount(newArr,combinedOdd,2.89),  // get the number of home wins whose odd is greater than 2.89 ---- <4
        awayWins       = aWayWinCount(newArr,combinedOdd,2.89), // <4
        drawWins       = drawWinCount(newArr,combinedOdd,6);   //  <2

     let sumOfFirstAndLastFivePoducts = Number(firstFiveProduct+lastFiveProduct);
     let sumOfOddAndEvenOddProduct    = Number((findProductOfOddPosition(newArr) + findProductOfEvenPosition(newArr)).toFixed(4));

     let maxOddList = getMaxOddList(H_odds_1, D_odds_1, A_odds_1);
     let minOddList = getMinOddList(H_odds_1, D_odds_1, A_odds_1); 

     let minOddCount = getMinOddCountPerGame(minOddList,combinedOdd);
     let maxOddCount = getMaxOddCountPerGame(maxOddList,combinedOdd); 

	pp.push({ //'H':ar1HomeCounter,
            //   'D':ar2DCounter,
            //   'A':ar3ACounter,
            //   '_counter':centralCounter,
            //   'min_odd_counter':minOddCount,
            //   'max_odd_count':maxOddCount,
            //   'HW':homeWins,
            //   'AW':awayWins,
            //   'DW':drawWins,
            //   'GAME':newArr,
              'oddList':getCombinationOdds(newArr),
              'prod':findProductOfOdds(newArr),
              'sum':findSumOfOdds(newArr),
            //   'sum2':sumAllElements(getCombinationOdds(newArr)),
            //   'f_odd':findProductOfOddPosition(newArr),
            //   'f_even':findProductOfEvenPosition(newArr),
              'f5':firstFiveProduct,
              'l5':lastFiveProduct,
            //   'first_to_last':first_to_last,
            //   'last_to_first':last_to_first,
            //   'sumF5':sumOfFirstAndLastFivePoducts,
            //   'sumOE':sumOfOddAndEvenOddProduct,
            //   'diff1':Number(sumOfFirstAndLastFivePoducts - sumOfOddAndEvenOddProduct), 
          });
   });
  return pp;
}


function sumAllElements(ar){
   let total = 0;
   ar.forEach((item)=>{
        total+=item;
   });
   return Number(total.toFixed(2));
}



// for the first five games
function filterMaches_first_half(arr){
    let pp =[];   // this array holds the count for each market
    arr.forEach((ar,index)=>{ 
		 let newArr =[];
		 for(let j=0; j< ar.length; j++){
		     if(ar1_first_half.includes(ar[j])){   // ar1 Home odds 
				newArr.push(ar1_first_half[j]);				
			 } else if(ar2_first_half.includes(ar[j])){  // ar2 Draw odds  
				newArr.push(ar2_first_half[j]);
			 }
			 else if(ar3_first_half.includes(ar[j])){   //ar3 Away odds  
				newArr.push(ar3_first_half[j]);
			 }else{
			    // do nothing
				console.log("nothig to do");
			 }
		 }  
    let combinedOdd  = getCombinationOdds_hf1(newArr);    // get the odd list of the game combination  

	pp.push({ 'GAME':newArr,  'oddList':combinedOdd, 'prod':findProductOfOdds_hf1(newArr) });
   });
  return pp;
}



// for the Second five games
function filterMaches_second_half(arr){
    let pp =[];   // this array holds the count for each market
    arr.forEach((ar,index)=>{ 
		 let newArr =[];
		 for(let j=0; j< ar.length; j++){
		     if(ar1_second_half.includes(ar[j])){   // ar1 Home odds 
				newArr.push(ar1_second_half[j]);				
			 } else if(ar2_second_half.includes(ar[j])){  // ar2 Draw odds  
				newArr.push(ar2_second_half[j]);
			 }
			 else if(ar3_second_half.includes(ar[j])){   //ar3 Away odds  
				newArr.push(ar3_second_half[j]);
			 }else{
			    // do nothing
				console.log("nothig to do");
			 }
		 }  
    let combinedOdd  = getCombinationOdds_hf2(newArr);    // get the odd list of the game combination  

	pp.push({  'GAME':newArr, 'oddList':combinedOdd, 'prod':findProductOfOdds_hf2(newArr) });

   });
  return pp;
}


function compareArr(a1,a2){
      let len1 = a1.length, len2 = a2.length; 
      if(len1===len2) return a1.toString() === a2.toString();    
}

// The output of analysis
const pp = filterMaches(PossibleOutCome);
// overal ranking
const sorted_pp = pp.sort((a,b)=> a.prod - b.prod);
console.log(sorted_pp);

const pp_1 = filterMaches_first_half(PossibleOut_hf1);
// console.log(pp_1);
const pp_2 = filterMaches_second_half(PossibleOut_hf2)
// console.log(pp_2);

const sorted_pp_1 = pp_1.sort((a,b) => a.prod - b.prod );
const sorted_pp_2 = pp_2.sort((a,b) => a.prod - b.prod );



// console.log(sorted_pp_1);
// console.log(sorted_pp_2);

// multipy out the procudct of the elements corresponding to their positions on the two lists of the first half 243 and second half 243
function getCrossProduct_f5_l5(a,b){
    let res = [], prod =1;
    for( let i = 0; i < b.length; i++){
        prod = a[i].prod * b[i].prod;
        prod = Number(prod.toFixed(2));
        res.push({'prod':prod,'a':a[i], 'b':b[i]});
    }
    return res;
}


let Resultant = getCrossProduct_f5_l5(pp_1,pp_2);
// console.log(Resultant);
//================================================================================================================

/* 
    Partition each of the sorted 243 set into rows of 38 each and then into 
    rows of 5 each after it is found that the remainder is 15
*/


 function sliceIntoChunks(arr, chunkSize,newChunkSize) {
    const res = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
        const chunk = arr.slice(i, i + chunkSize);
        if(chunk.length === chunkSize){
            res.push(chunk); 
        } else{
            if(newChunkSize){
                seconTier(chunk, newChunkSize);
            }
             
        }
    }
// this sub function will take the last chunk and perfomr the operation and break into 5 - 5 chunks
    function seconTier(a, chunk_size){
        for (let i = 0; i < a.length; i += chunk_size) {
            const nwChunk = a.slice(i, i + chunk_size);
            res.push(nwChunk); 
        }
    }

    return res;
}

// console.log(sliceIntoChunks(pp_1, 38,5));
// console.log(sliceIntoChunks(pp_2, 38,5));

// Spliting the 243 set of Numerator and Denominator
const firstSet_243_rows  = sliceIntoChunks(pp_1, 38,5);
const secondSet_243_rows = sliceIntoChunks(pp_2, 38,5);
//=======================================================//



/* 
 This function does the following things:
 1. spit the entire 59049 sample space in to buches of 243 
 2. split each of the 243 into chunks of 38 and then into chunks of 5 for the last 15 sets
 3. using one of the 59k data test to get the correct table number, the row and column position 
    inside the 243 which was already splited into chuns of 38 and then 5
 4. Map the row and column positions to those of them in the SEPARATE NUMERATOR AND DENOMINATOR
    and return the values for which the product: NUM(x,y)*D(x,y) = G(x,y)
*/


function runMappingAnalysis(inputAr){

   /// Split the  59059 into sets of 243 each 
    let newSets_243 = sliceIntoChunks(inputAr, 243);

    // REPORT THE 243 ARRAYS IN BLOCKS OF 38 
   let subset_243 = sliceIntoChunks(newSets_243, 38, 5);

//  const broken_downfuther =[];
//   // then futher split into 38 sets and then 5
//    for (let item of newSets_243) {
//        let new_sets = sliceIntoChunks(item, 38,5);
//        broken_downfuther.push(new_sets);
//    }
//    console.log(newSets_243);
//    console.log(broken_downfuther);
   console.log(subset_243);

    // Keep record f any of the 59049 that saisfy the condition
    let testResultArr = [];

     // This inner function does the actual analysis
    function innerAnalysis(inputAr){ 
        inputAr.forEach((a)=>{
            let testInput     = a.prod;  // you can still get f5 and l5
            let filerout_test = broken_downfuther.find((a) => a.find((b) => b.find((c) => c.prod === testInput)));
        // console.log(filerout_test);
        // get the table position
            let tablePos      = broken_downfuther.indexOf(filerout_test);

            // find the base of the test input
            let HR_base_search = filerout_test.find((a) => a.find((b)=> b.prod === testInput));
            // console.log(HR_base_search);
            // get the horizontal rank 
            let hr = filerout_test.indexOf(HR_base_search); 

            // get the vertical rank
            let vr = HR_base_search.find((a) => a.prod === testInput);
                vr = HR_base_search.indexOf(vr)

            let N_x_y = firstSet_243_rows[hr][vr];
            let D_x_y = secondSet_243_rows[hr][vr];
            // console.log(tablePos, hr , vr);
            let product_f5_l5 = Number((N_x_y.prod * D_x_y.prod).toFixed(2));

            // check if the testInut is same as the product of the l5 and f5 of the NUMBERATOR and Denominator
            if(product_f5_l5 == testInput){
                testResultArr.push(
                    {
                        'testInput':a,
                        'prodResult':product_f5_l5,
                        'TabNo':tablePos,
                        'x_y':[hr,vr],
                        'N_x_y':N_x_y,
                        'D_x_y':D_x_y
                    }
              );
            }

        });
    }
    // innerAnalysis(inputAr);

    // return testResultArr;
}

// running the analysis
// let analysisResult = runMappingAnalysis(pp);   // testing for just one value
// console.log(analysisResult);
let newSets_243_of59k = sliceIntoChunks(pp, 243);
console.log(newSets_243_of59k);
let newSets_243_of59k_sub_38 = sliceIntoChunks(newSets_243_of59k, 38,5);
console.log(newSets_243_of59k_sub_38);
//===================================================================================================
let newSets_38_of59k = sliceIntoChunks(pp, 38,35);
console.log(newSets_38_of59k);

function getSumOfodds_38_of59k_btw_1100_1140(inputArr){
     const result =[];
    for (let item of inputArr){
          let sums = sumAllElements(item),
              average = Number((sums/380).toFixed(2));
          if(average === 2.89){
            result.push(item);
          }
    }
    function sumAllElements(ar){
        let total = 0;
        for(let a of ar){  total+=a.sum; }
         return Number(total.toFixed(2));
     }
  return result;
}

const resultOfSums = getSumOfodds_38_of59k_btw_1100_1140(newSets_38_of59k);
console.log(resultOfSums);
// let ranksResult = generateRanks(sorted_pp[798], [pp_1,pp_2],firstSet_243_rows, secondSet_243_rows);
//==================================================================================================//


//==================================================================================================//






// console.log(ranksResult);
const o_of_ranked_59k =[];
const allEqual = arr => arr.every(val => val === arr[0]);  // this function checks if all the elements in an array are equal

for (let item of sorted_pp){
    let ranksResult = generateRanks(item, [pp_1,pp_2],firstSet_243_rows, secondSet_243_rows);
    // let check       = allEqual(ranksResult[2]);
    o_of_ranked_59k.push({'xteristics':ranksResult,'result':item, 'rank':pp.indexOf(item)});
}
// let ranksResult   = generateRanks(sorted_pp[0], [pp_1,pp_2],firstSet_243_rows, secondSet_243_rows);

// console.log(ranksResult);

// console.log(o_of_ranked_59k);
// let fil_10_11 = o_of_ranked_59k.filter((a) => a.result.prod >= 1455 && a.result.prod <=1456);
// console.log(fil_10_11);
// //sorted_pp

// selected few with same characteristics
// let selectedFew = sorted_pp.filter((a) => a.prod >500000);
// console.log(selectedFew);
// Rus function attempts to find the [GR, VR, and HR] of a given 
// odd product coordinates, 
// OD(n,d) where n is the NUMBERATOR and d is the DENOMINATOR

function generateRanks(hayStack, global_243,numerator, denominator){
    // get the first five and last five products from the origial sets of 59049
       let f5 = hayStack.f5, 
           l5 = hayStack.l5;

       let RANKED_BASE_NUM  = generateHorizontalRank(f5,numerator)[0];
       let RANKED_BASE_DENO = generateHorizontalRank(l5,denominator)[0];
           // Considering Numerator
        // filter out the products
       let g_R_1     = global_243[0].find((a) => a.prod === f5 ),
            gR_1     = [global_243[0].indexOf(g_R_1), g_R_1.prod]; // Global 1 [position, product] : Numerator

       let vR_1    = [RANKED_BASE_NUM.rowRank, RANKED_BASE_NUM.val];  // vertical rank 1 [position, product] 
       let HR_1    = [RANKED_BASE_NUM.colRank, RANKED_BASE_NUM.val];  // horizontal rank 1 [position, product]

        // Considering DENOMINATOR
        // filter out the products
       let g_R_2    = global_243[1].find((a)  => a.prod === l5 )          // filter out vaues  
       let gR_2     = [global_243[1].indexOf(g_R_2), g_R_2.prod];        // Global 2 [position, product] : Denominator

       let vR_2     = [RANKED_BASE_DENO.colRank, RANKED_BASE_DENO.val];   // vertical rank 1 [position, product] 
       let HR_2     = [RANKED_BASE_DENO.rowRank, RANKED_BASE_DENO.val];  // horizontal rank 1 [position, product]

        // this function generates Horizontal Rank item
       function generateHorizontalRank(searchKey,ar){ 
          let bucket    = ar.find((a) => a.find((item) => item.prod === searchKey)  ); // identify the row it belongs to
          let foundItem = bucket.filter((item) => item.prod === searchKey);
          return [{'rowRank':ar.indexOf(bucket), 'colRank':bucket.indexOf(foundItem[0]),'val':foundItem[0].prod}];
        //   return ar.indexOf(bucket);
        //   return bucket?.indexOf(foundItem);
       }

       // this function generates Vertical Rank item for the both denominator and the Numerator
    //    function generateVerticalRank(searchKey,ar){   
    //            let bucket    = ar.find((a) => a.find((item) => item.prod === searchKey)  ); 
    //            let foundItem = bucket?.find((item) => item.prod === searchKey);

    //            function getColumnAr(item){ 
    //                 for(let a of ar){
    //                    if(a.includes(item)){
    //                     return ar.indexOf(a);
    //                    }
    //                 }  
    //            }
    //            let column_a_pos = getColumnAr(foundItem);
    //            return column_a_pos;
    //    }
       let crossP_output =[];
       function rankCrosProduct(firstRanksSet,secondRankSet){  // firstRanksSet = [gR_1,vR_1,HR_1], secondRankSet = [gR_2,vR_2,HR_2]
           firstRanksSet.forEach((item1)=>{
                let totalOdd;
                secondRankSet.forEach((item2)=>{
                    totalOdd = Number((item1 * item2).toFixed(2));
                    crossP_output.push(totalOdd);
                });
            });
       }
       rankCrosProduct([gR_1[1],vR_1[1],HR_1[1]],[gR_2[1],vR_2[1],HR_2[1]]);
 return [ { 'gR_1':gR_1, 'vR_1':vR_1,'HR_1':HR_1},{'gR_2':gR_2,'vR_2':vR_2,'HR_2':HR_2}, crossP_output];
 

}


/*
  Cobine the two possible outcomes of 
  the first and second games 
*/
const CombinedSet_59k =[];
pp_1.forEach((item1)=>{
    let totalOdd;
    pp_2.forEach((item2)=>{
        totalOdd = Number((item1.prod * item2.prod).toFixed(2));
        CombinedSet_59k.push({'combinedOdd':totalOdd, 'f5':item1, 'l5':item2});
    });
});

const sorted_combined = CombinedSet_59k.sort((a,b)=> a.combinedOdd -b.combinedOdd);
// console.log(sorted_combined);
// ====================================================================================================================

function __compare__Arrays(a,b){
    let res =[];
    for(let i =0; i < a.length; i++){
        if(a[i].prod === b[i].combinedOdd){
            res.push({'original':a[i], 'combined':b[i]});
        }
    }
    return res;
}

// console.log(__compare__Arrays(sorted_pp,sorted_combined));










//  rank of first five
// console.log(pp.sort((a,b)=> a.f5 -b.f5));


// // rank of last five 
// console.log(pp.sort((a,b)=> a.l5 -b.l5));

//Get the mimimun odd list per Round
const roundMinOddList = getMinOddList(H_odds_1,D_odds_1,A_odds_1);

// Show the combination out of the 59049 outputs that has he minimum odds
const minOddsOf59K = pp.filter((ar)=> compareArr(roundMinOddList,ar.oddList));
// console.log(minOddsOf59K);

// MAIN OPERATIONAL OUTPUT
//   let o_range    = pp.filter((ar) => ar.prod>=500000);   
//   let o_range_1  = pp.filter((ar) => ar.prod<500000); 
//   console.log( o_range ); 
//   console.log( o_range_1 ); 
//   // for round 12
//   let gt_18804  = pp.filter((ar) => ar.prod>18804 );   
//   let lt_18804  = pp.filter((ar) => ar.prod<18804 ); 

//   //for round 6
//   let gt_3642_84  = pp.filter((ar) => ar.prod>3642.84 );   
//   let lt_3642_84  = pp.filter((ar) => ar.prod<3642.84 ); 

//   //for round 18
//   let gt_69986_45  = pp.filter((ar) => ar.prod>69986.45 );   
//   let lt_69986_45  = pp.filter((ar) => ar.prod<69986.45 );   
  
// console.log( "Between 18804 And 19767");  
// console.log( o_range); 
// console.log( "Between 18804 And 19009");  
// console.log( o_range_1);  
// console.log( "Between 18743 and 19706");  
// console.log( o_range_2); 

// console.log( "Greater than 18804");  
// console.log( gt_18804 ); 
// let maxFunc = function (a){
//         let items =[];
//         a.forEach((ar,index)=>{
//               items.push(ar.prod);  
//         });
//     let min = Math.min(...items);
//     return min;
// }
// console.log( maxFunc(gt_18804) ); 

// let minFunc = (a)=>{
//     let items =[];
//         a.forEach((ar,index)=>{
//               items.push(ar.prod);  
//         });
//     let max = Math.max(...items);
//     return max;
// }

// console.log( "Less Than 18804");  
// console.log( lt_18804 ); 
// console.log( minFunc(lt_18804) ); 




// console.log( "Greater than 3642.84");  
// console.log( gt_69986_45 ); 

// console.log( "Less Than 3642.84");  
// console.log( lt_3642_84 ); 

let maxFunc = function (a){
        let items =[];
        a.forEach((ar,index)=>{  items.push(ar.prod);   });
    let min      = Math.min(...items), 
        minItems = items.sort((a, b)=>{return b - a}).slice(-5);
    return minItems;
}

let minFunc = (a)=>{
    let items =[];
        a.forEach((ar,index)=>{  items.push(ar.prod);  });
    let max      = Math.max(...items), 
        maxItems = items.sort((a, b)=>{return b - a}).slice(0,5);  
    return maxItems;
}

//console.log( ` Least Max: ${maxFunc(gt_69986_45)}, Largest Min: ${minFunc(lt_69986_45)}` ); 
 


//
// let product      = productOfOddsByCriteria(criteria());
// let prod_odLow   = productOfOddPositionByCriteria(criteria())-1,     prod_oddHigh   = productOfOddPositionByCriteria(criteria())+1;
// let prod_evenLow = productOfEvenPositionByCriteria(criteria())-1,    prod_evenHigh  = productOfEvenPositionByCriteria(criteria())+1;

// // Using Upper and Lower limit calculation
// let _g514_1 = pp.filter((ar) => ar.sumF5-ar.sumOE>=-2 && ar.sumF5-ar.sumOE<=2 && ar._counter<5); 

// let _g514_12 = pp.filter((ar) => ar.sumF5-ar.sumOE>=-1 && ar.sumF5-ar.sumOE<=1 && ar._counter<5); 

// let _g514_13 = pp.filter((ar) => { return  ar.sumF5 === ar.sumOE; }); 

// // min_odd_counter  max_odd_count
// let _g514_11 = pp.filter((ar) => {  
//      return ar.H>=2 && ar.D<=5 && ar.A<=5 && ar.HW<4 && ar.AW<4 && ar.DW<2 && ar.min_odd_counter>=4 && ar.max_odd_count<=3
//    } )?.sort((a, b) => (a > b ? 1 : -1)); 


// console.log(criteria());
// console.log(`The Product is : ${productOfOddsByCriteria(criteria())}`);
// console.log(`The product of Odd Position: ${productOfOddPositionByCriteria(criteria())}`);
// console.log(`The product of Even Position: ${productOfEvenPositionByCriteria(criteria())}`);


// This function attempt to select rounds_38 of the entire sample space
function selectRounds38(givenArray){
     let size = 38; 
     const result = givenArray.reduce((acc, _, i) => {
          if (i <= givenArray.length - size) acc.push(givenArray.slice(i, i + size))  
              return acc 
         }, [])

     return result;
}

// a.R[0] = Home  Odds,   a.R[1] = Draw Odds, a.R[2] = Away Odds 
function getRounds_and_odds(arr){
     let newExpected = selectRounds38(PossibleOutCome), expectedSum=[], counter =0, arrayOf38RoundsofSums =[]; 
          
          for(let j=0; j< newExpected.length; j++){
               let  gameArray = newExpected[j],sums = 0;

               for(let i =0; i< gameArray.length; i++){ 
                    sums += findSumOfOddsWithParams(gameArray[i],arr[counter][0],arr[counter][1],arr[counter][2]);               
               } 
               
             if(sums>=1043 && sums<=1100) expectedSum.push(sums);             
          }
          while(counter<arr.leghth){
                arrayOf38RoundsofSums.push(expectedSum);
                counter++;
          }
 
     return   [newExpected,expectedSum,arrayOf38RoundsofSums];  
}

//Rounds
let newExpected = selectRounds38(PossibleOutCome);
// console.log(newExpected);

let sumsArr =[];
newExpected.forEach((arr,index)=>{
      // get the sum of of the odds of the 380 Matches
         let sumFUnc = (ar)=>{
            let sum =0;
            for(let i =0; i<ar.length; i++){
                sum += findSumOfOddsWithParams(ar[i],Rounds[0]);   
            }
            return sum;
        }
        //Number(sumFUnc(arr,Rounds[index]).toFixed(2))
        sumsArr.push(index);
});

// Display the sum of the odds for the 38 rounds
//console.log(sumsArr);

// How many of the sums of the odds of the 38 rounds fall between 1043 and 1100
// let sumsIntheRange = sumsArr.filter((a)=> a>=1000 && a<=1400);

// console.log(sumsIntheRange);
  

let round_38    = getRounds_and_odds(Rounds);
// console.log(round_38); 
 
let sss = round_38[1].filter((a)=> a<=1043.28);

// console.log(sss)
// console.log([1.57, 4.65, 2.54, 6.93, 2.6, 1.86, 2.42, 2.02, 1.24, 4.35].reduce((prev,curr)=> prev +curr ))
// let comp = oddCompare([1.57, 4.65, 2.54, 6.93, 2.6, 1.86, 2.42, 2.02, 1.24, 4.35],5.5);
// console.log(comp);


   
</script>




</body>


</html>